## Codes Executed
-- Drop access_log table if it exists
DROP TABLE access_log CASCADE CONSTRAINTS;

-- Drop employees table if it exists
DROP TABLE employees CASCADE CONSTRAINTS;
-- Create a table to log blocked access attempts
CREATE TABLE access_log (
    log_id       NUMBER GENERATED BY DEFAULT AS IDENTITY, -- auto increment
    username     VARCHAR2(50),   -- who attempted access
    action_time  DATE,           -- when the attempt happened
    action_type  VARCHAR2(50),   -- INSERT/UPDATE/DELETE
    reason       VARCHAR2(200)   -- why it was blocked
);

-- A simple table used for testing the trigger
CREATE TABLE employees (
    emp_id NUMBER,
    name   VARCHAR2(50)
);

-- Trigger to prevent operations on weekends or outside working hours
CREATE OR REPLACE TRIGGER trg_block_access
BEFORE INSERT OR UPDATE OR DELETE ON employees
BEGIN
    -- Block on Saturday or Sunday
    IF TO_CHAR(SYSDATE, 'D') IN ('1','7') THEN
        RAISE_APPLICATION_ERROR(-20001, 'Access not allowed on Weekend.');
    END IF;

    -- Block outside 8AM–5PM
    IF TO_CHAR(SYSDATE, 'HH24') NOT BETWEEN '08' AND '17' THEN
        RAISE_APPLICATION_ERROR(-20002, 'Access allowed only between 8AM–5PM.');
    END IF;
END;
/

ALTER TRIGGER trg_block_access DISABLE;

INSERT INTO employees VALUES (1, 'James');
INSERT INTO employees VALUES (2, 'John');
INSERT INTO employees VALUES (3, 'Peter');
INSERT INTO employees VALUES (4, 'Peace');
INSERT INTO employees VALUES (5, 'Ora');

ALTER TRIGGER trg_block_access ENABLE;

CREATE OR REPLACE TRIGGER trg_log_violations
AFTER SERVERERROR ON DATABASE
DECLARE
    v_err  VARCHAR2(200);
    v_user VARCHAR2(50);
BEGIN
    -- Capture error message
    v_err := SUBSTR(DBMS_UTILITY.format_error_stack,1,200);
    v_user := SYS_CONTEXT('USERENV', 'SESSION_USER');

    INSERT INTO access_log(username, action_time, action_type, reason)
    VALUES (v_user, SYSDATE, 'BLOCKED_OPERATION', v_err);
END;
/

DROP TABLE hr_employees CASCADE CONSTRAINTS;

CREATE TABLE hr_employees (
    emp_id     NUMBER PRIMARY KEY,
    name       VARCHAR2(50),
    salary     NUMBER
);
INSERT INTO hr_employees VALUES (1, 'James', 500000);
INSERT INTO hr_employees VALUES (2, 'John', 350000);

CREATE OR REPLACE PACKAGE hr_pack AS

    -- FUNCTION: Calculate net salary after RSSB 3%
    FUNCTION calc_net_salary(p_salary NUMBER) RETURN NUMBER;

    -- PROCEDURE: Update employee salary using dynamic SQL
    PROCEDURE update_salary_dynamic(p_emp_id NUMBER, p_new_salary NUMBER);

    -- FUNCTION: Show USER vs CURRENT_USER
    FUNCTION who_am_i RETURN VARCHAR2;

END hr_pack;
/

CREATE OR REPLACE PACKAGE BODY hr_pack AS

    -- Calculate salary minus 3% RSSB
    FUNCTION calc_net_salary(p_salary NUMBER)
    RETURN NUMBER IS
    BEGIN
        RETURN p_salary - (p_salary * 0.03);  -- simple tax rule
    END;

    -- Update salary using dynamic SQL
    PROCEDURE update_salary_dynamic(p_emp_id NUMBER, p_new_salary NUMBER) IS
        v_sql VARCHAR2(200);
    BEGIN
        v_sql := 'UPDATE hr_employees SET salary = :1 WHERE emp_id = :2';
        EXECUTE IMMEDIATE v_sql USING p_new_salary, p_emp_id;
    END;

    -- USER vs CURRENT_USER
    FUNCTION who_am_i RETURN VARCHAR2 IS
    BEGIN
        RETURN 'USER=' || USER ||
               ' | CURRENT_USER=' || SYS_CONTEXT('USERENV','CURRENT_USER');
    END;

END hr_pack;
/

SELECT hr_pack.calc_net_salary(500000) AS net_salary FROM dual;

BEGIN
    hr_pack.update_salary_dynamic(1, 600000);
END;
/

SELECT hr_pack.who_am_i FROM dual;


DROP TABLE login_audit CASCADE CONSTRAINTS;

CREATE TABLE login_audit (
    audit_id     NUMBER GENERATED BY DEFAULT AS IDENTITY,
    username     VARCHAR2(50),
    attempt_time DATE,
    status       VARCHAR2(10),
    ip_address   VARCHAR2(50)
);

DROP TABLE security_alerts CASCADE CONSTRAINTS;

CREATE TABLE security_alerts (
    alert_id      NUMBER GENERATED BY DEFAULT AS IDENTITY,
    username      VARCHAR2(50),
    failed_count  NUMBER,
    alert_time    DATE,
    alert_message VARCHAR2(200),
    contact       VARCHAR2(100)
);

CREATE OR REPLACE TRIGGER trg_login_security
AFTER INSERT ON login_audit
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    IF :NEW.status = 'FAILED' THEN
        -- Count failed attempts today
        SELECT COUNT(*)
        INTO v_count
        FROM login_audit
        WHERE username = :NEW.username
          AND status = 'FAILED'
          AND TRUNC(attempt_time) = TRUNC(SYSDATE);

        IF v_count > 2 THEN
            INSERT INTO security_alerts(username, failed_count, alert_time, alert_message, contact)
            VALUES (:NEW.username, v_count, SYSDATE,
                    'More than 2 failed login attempts detected',
                    'security@company.com');
        END IF;
    END IF;
END;
/


INSERT INTO login_audit(username, attempt_time, status) VALUES ('agape', SYSDATE, 'FAILED');
INSERT INTO login_audit(username, attempt_time, status) VALUES ('Karemera', SYSDATE, 'FAILED');
INSERT INTO login_audit(username, attempt_time, status) VALUES ('Bosco', SYSDATE, 'FAILED');  -- triggers alert

DROP TRIGGER trg_login_security;
CREATE OR REPLACE TRIGGER trg_login_security
FOR INSERT ON login_audit
COMPOUND TRIGGER

    TYPE fail_tab IS TABLE OF VARCHAR2(50);
    failed_users fail_tab := fail_tab();

    BEFORE EACH ROW IS
    BEGIN
        -- Only collect FAILED attempts
        IF :NEW.status = 'FAILED' THEN
            failed_users.EXTEND;
            failed_users(failed_users.LAST) := :NEW.username;
        END IF;
    END BEFORE EACH ROW;

    AFTER STATEMENT IS
    DECLARE
        v_count NUMBER;
    BEGIN
        -- Loop through all failed users in this statement
        FOR i IN 1 .. failed_users.COUNT LOOP

            SELECT COUNT(*)
            INTO v_count
            FROM login_audit
            WHERE username = failed_users(i)
            AND status = 'FAILED'
            AND TRUNC(attempt_time) = TRUNC(SYSDATE);

            -- If more than 2 failures, create alert
            IF v_count > 2 THEN
                INSERT INTO security_alerts(username, failed_count, alert_time, alert_message, contact)
                VALUES (failed_users(i), v_count, SYSDATE,
                        'More than 2 failed login attempts detected',
                        'security@company.com');
            END IF;

        END LOOP;
    END AFTER STATEMENT;

END trg_login_security;
/


CREATE OR REPLACE TRIGGER trg_login_security
FOR INSERT ON login_audit
COMPOUND TRIGGER

    TYPE fail_tab IS TABLE OF VARCHAR2(50);
    failed_users fail_tab := fail_tab();

    BEFORE EACH ROW IS
    BEGIN
        -- Only collect failed login attempts
        IF :NEW.status = 'FAILED' THEN
            failed_users.EXTEND;
            failed_users(failed_users.LAST) := :NEW.username;
        END IF;
    END BEFORE EACH ROW;

    AFTER STATEMENT IS
        v_count NUMBER;
    BEGIN
        -- Loop through all collected failed users
        FOR i IN 1 .. failed_users.COUNT LOOP

            SELECT COUNT(*)
            INTO v_count
            FROM login_audit
            WHERE username = failed_users(i)
              AND status = 'FAILED'
              AND TRUNC(attempt_time) = TRUNC(SYSDATE);

            IF v_count > 2 THEN
                INSERT INTO security_alerts
                (username, failed_count, alert_time, alert_message, contact)
                VALUES
                (failed_users(i), v_count, SYSDATE,
                 'More than 2 failed login attempts detected',
                 'security@company.com');
            END IF;

        END LOOP;
    END AFTER STATEMENT;

END trg_login_security;
/

INSERT INTO login_audit(username, attempt_time, status)
VALUES ('agape', SYSDATE, 'FAILED');

INSERT INTO login_audit(username, attempt_time, status)
VALUES ('Karemera', SYSDATE, 'FAILED');

INSERT INTO login_audit(username, attempt_time, status)
VALUES ('santos', SYSDATE, 'FAILED');
